/**
 * Analytics Export Utilities
 * Handles data export functionality for reports (PDF, Excel, CSV)
 * Supports multiple data formats and customizable report templates
 */

import { format } from 'date-fns';

// Types for export data
export interface ExportData {
  title: string;
  subtitle?: string;
  headers: string[];
  rows: (string | number)[][];
  metadata?: {
    generatedAt: string;
    generatedBy: string;
    period: string;
    restaurant: string;
  };
  summary?: {
    [key: string]: string | number;
  };
}

export interface ChartData {
  type: 'line' | 'bar' | 'pie' | 'area';
  title: string;
  data: any[];
  xAxis?: string;
  yAxis?: string;
}

export interface ExportOptions {
  format: 'pdf' | 'excel' | 'csv';
  filename?: string;
  includeCharts?: boolean;
  includeSummary?: boolean;
  template?: 'standard' | 'executive' | 'detailed';
  locale?: string;
}

/**
 * Export data as CSV format
 */
export function exportToCSV(data: ExportData, options: ExportOptions = { format: 'csv' }): void {
  const { title, headers, rows, metadata, summary } = data;
  
  let csvContent = '';
  
  // Add title and metadata
  csvContent += `"${title}"\n`;
  if (metadata) {
    csvContent += `"Generated At:","${metadata.generatedAt}"\n`;
    csvContent += `"Generated By:","${metadata.generatedBy}"\n`;
    csvContent += `"Period:","${metadata.period}"\n`;
    csvContent += `"Restaurant:","${metadata.restaurant}"\n`;
    csvContent += '\n';
  }
  
  // Add headers
  csvContent += headers.map(header => `"${header}"`).join(',') + '\n';
  
  // Add rows
  rows.forEach(row => {
    const csvRow = row.map(cell => {
      if (typeof cell === 'string') {
        return `"${cell.replace(/"/g, '""')}"`;
      }
      return cell;
    }).join(',');
    csvContent += csvRow + '\n';
  });
  
  // Add summary if included
  if (summary && options.includeSummary) {
    csvContent += '\n"Summary:"\n';
    Object.entries(summary).forEach(([key, value]) => {
      csvContent += `"${key}","${value}"\n`;
    });
  }
  
  // Create and download file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const filename = options.filename || `${title.replace(/\s+/g, '_')}_${format(new Date(), 'yyyy-MM-dd')}.csv`;
  downloadFile(blob, filename);
}

/**
 * Export data as Excel format (simplified XLSX)
 */
export function exportToExcel(data: ExportData, options: ExportOptions = { format: 'excel' }): void {
  // For a full Excel export, you would typically use a library like xlsx or exceljs
  // This is a simplified version that creates a tab-separated values file with .xlsx extension
  // In a production environment, you should implement proper Excel export
  
  const { title, headers, rows, metadata, summary } = data;
  
  let content = '';
  
  // Add title and metadata
  content += `${title}\n`;
  if (metadata) {
    content += `Generated At:\t${metadata.generatedAt}\n`;
    content += `Generated By:\t${metadata.generatedBy}\n`;
    content += `Period:\t${metadata.period}\n`;
    content += `Restaurant:\t${metadata.restaurant}\n`;
    content += '\n';
  }
  
  // Add headers
  content += headers.join('\t') + '\n';
  
  // Add rows
  rows.forEach(row => {
    content += row.join('\t') + '\n';
  });
  
  // Add summary if included
  if (summary && options.includeSummary) {
    content += '\nSummary:\n';
    Object.entries(summary).forEach(([key, value]) => {
      content += `${key}\t${value}\n`;
    });
  }
  
  // Create and download file
  const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = options.filename || `${title.replace(/\s+/g, '_')}_${format(new Date(), 'yyyy-MM-dd')}.xlsx`;
  downloadFile(blob, filename);
}

/**
 * Export data as PDF format
 */
export function exportToPDF(data: ExportData, charts: ChartData[] = [], options: ExportOptions = { format: 'pdf' }): void {
  // For a full PDF export, you would typically use a library like jsPDF or PDFKit
  // This is a simplified version that creates an HTML page for printing
  // In a production environment, you should implement proper PDF generation
  
  const { title, headers, rows, metadata, summary } = data;
  
  let htmlContent = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>${title}</title>
      <style>
        body { 
          font-family: Arial, sans-serif; 
          margin: 20px; 
          color: #333;
        }
        .header { 
          text-align: center; 
          margin-bottom: 30px; 
          border-bottom: 2px solid #E31B23;
          padding-bottom: 20px;
        }
        .title { 
          font-size: 24px; 
          font-weight: bold; 
          color: #E31B23; 
          margin-bottom: 10px;
        }
        .metadata { 
          margin-bottom: 20px; 
          background-color: #f8f9fa;
          padding: 15px;
          border-radius: 5px;
        }
        .metadata table {
          width: 100%;
          border-collapse: collapse;
        }
        .metadata td {
          padding: 5px 10px;
          border-bottom: 1px solid #dee2e6;
        }
        .metadata td:first-child {
          font-weight: bold;
          width: 150px;
        }
        table { 
          width: 100%; 
          border-collapse: collapse; 
          margin: 20px 0;
        }
        th, td { 
          border: 1px solid #ddd; 
          padding: 12px 8px; 
          text-align: left; 
        }
        th { 
          background-color: #E31B23; 
          color: white; 
          font-weight: bold;
        }
        tr:nth-child(even) { 
          background-color: #f2f2f2; 
        }
        tr:hover {
          background-color: #e8f4fd;
        }
        .summary {
          margin-top: 30px;
          background-color: #e8f4fd;
          padding: 20px;
          border-radius: 5px;
          border-left: 4px solid #008B8B;
        }
        .summary h3 {
          margin-top: 0;
          color: #008B8B;
        }
        .summary table {
          margin: 10px 0;
        }
        .footer {
          margin-top: 40px;
          text-align: center;
          font-size: 12px;
          color: #666;
          border-top: 1px solid #ddd;
          padding-top: 20px;
        }
        @media print {
          body { margin: 0; }
          .no-print { display: none; }
        }
      </style>
    </head>
    <body>
      <div class="header">
        <div class="title">${title}</div>
        ${data.subtitle ? `<div class="subtitle">${data.subtitle}</div>` : ''}
      </div>
  `;
  
  // Add metadata
  if (metadata) {
    htmlContent += `
      <div class="metadata">
        <table>
          <tr><td>Generated At:</td><td>${metadata.generatedAt}</td></tr>
          <tr><td>Generated By:</td><td>${metadata.generatedBy}</td></tr>
          <tr><td>Period:</td><td>${metadata.period}</td></tr>
          <tr><td>Restaurant:</td><td>${metadata.restaurant}</td></tr>
        </table>
      </div>
    `;
  }
  
  // Add main data table
  htmlContent += `
    <table>
      <thead>
        <tr>
          ${headers.map(header => `<th>${header}</th>`).join('')}
        </tr>
      </thead>
      <tbody>
        ${rows.map(row => `
          <tr>
            ${row.map(cell => `<td>${cell}</td>`).join('')}
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;
  
  // Add summary if included
  if (summary && options.includeSummary) {
    htmlContent += `
      <div class="summary">
        <h3>Summary</h3>
        <table>
          ${Object.entries(summary).map(([key, value]) => `
            <tr>
              <td style="font-weight: bold; width: 200px;">${key}:</td>
              <td>${value}</td>
            </tr>
          `).join('')}
        </table>
      </div>
    `;
  }
  
  // Add footer
  htmlContent += `
      <div class="footer">
        <p>Generated on ${new Date().toLocaleString()} | Restaurant Krong Thai SOP Management System</p>
      </div>
    </body>
    </html>
  `;
  
  // Open in new window for printing/saving as PDF
  const printWindow = window.open('', '_blank');
  if (printWindow) {
    printWindow.document.write(htmlContent);
    printWindow.document.close();
    printWindow.focus();
    
    // Auto-trigger print dialog
    setTimeout(() => {
      printWindow.print();
    }, 250);
  }
}

/**
 * Helper function to download a file
 */
function downloadFile(blob: Blob, filename: string): void {
  const url = window.URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up the URL object
  window.URL.revokeObjectURL(url);
}

/**
 * Format analytics data for export
 */
export function formatAnalyticsData(
  type: 'sop' | 'training' | 'operational' | 'executive',
  rawData: any[],
  locale: string = 'en'
): ExportData {
  const now = new Date();
  
  switch (type) {
    case 'sop':
      return {
        title: 'SOP Usage Analytics Report',
        subtitle: 'Standard Operating Procedures Performance Analysis',
        headers: ['SOP Title', 'Category', 'Views', 'Unique Users', 'Completion Rate', 'Compliance Score'],
        rows: rawData.map(sop => [
          sop.title,
          sop.category,
          sop.views,
          sop.uniqueUsers,
          `${sop.completionRate}%`,
          `${sop.complianceScore}%`
        ]),
        metadata: {
          generatedAt: format(now, 'yyyy-MM-dd HH:mm:ss'),
          generatedBy: 'System Administrator',
          period: 'Last 30 days',
          restaurant: 'Krong Thai Restaurant'
        },
        summary: {
          'Total SOPs': rawData.length,
          'Total Views': rawData.reduce((sum, sop) => sum + sop.views, 0),
          'Average Completion Rate': `${(rawData.reduce((sum, sop) => sum + sop.completionRate, 0) / rawData.length).toFixed(1)}%`,
          'Average Compliance Score': `${(rawData.reduce((sum, sop) => sum + sop.complianceScore, 0) / rawData.length).toFixed(1)}%`
        }
      };
      
    case 'training':
      return {
        title: 'Training Analytics Report',
        subtitle: 'Staff Training Performance and ROI Analysis',
        headers: ['Module', 'Enrollments', 'Completions', 'Average Score', 'Certificates Issued', 'ROI'],
        rows: rawData.map(module => [
          module.title,
          module.enrollments,
          module.completions,
          `${module.averageScore}%`,
          module.certificates,
          `${module.roi}%`
        ]),
        metadata: {
          generatedAt: format(now, 'yyyy-MM-dd HH:mm:ss'),
          generatedBy: 'Training Manager',
          period: 'Last 30 days',
          restaurant: 'Krong Thai Restaurant'
        },
        summary: {
          'Total Modules': rawData.length,
          'Total Enrollments': rawData.reduce((sum, module) => sum + module.enrollments, 0),
          'Total Completions': rawData.reduce((sum, module) => sum + module.completions, 0),
          'Average ROI': `${(rawData.reduce((sum, module) => sum + module.roi, 0) / rawData.length).toFixed(1)}%`
        }
      };
      
    case 'operational':
      return {
        title: 'Operational Insights Report',
        subtitle: 'Restaurant Efficiency and Performance Metrics',
        headers: ['Metric', 'Current Value', 'Target', 'Status', 'Trend'],
        rows: rawData.map(metric => [
          metric.name,
          `${metric.current}${metric.unit}`,
          `${metric.target}${metric.unit}`,
          metric.status,
          metric.trend
        ]),
        metadata: {
          generatedAt: format(now, 'yyyy-MM-dd HH:mm:ss'),
          generatedBy: 'Operations Manager',
          period: 'Last 7 days',
          restaurant: 'Krong Thai Restaurant'
        },
        summary: {
          'Total Metrics': rawData.length,
          'Healthy Metrics': rawData.filter(m => m.status === 'healthy').length,
          'Warning Metrics': rawData.filter(m => m.status === 'warning').length,
          'Critical Metrics': rawData.filter(m => m.status === 'critical').length
        }
      };
      
    case 'executive':
    default:
      return {
        title: 'Executive Dashboard Report',
        subtitle: 'Comprehensive Business Intelligence Summary',
        headers: ['KPI', 'Current Value', 'Target', 'Achievement', 'Trend'],
        rows: rawData.map(kpi => [
          kpi.title,
          kpi.value,
          kpi.target || 'N/A',
          kpi.target ? `${Math.round((kpi.value / kpi.target) * 100)}%` : 'N/A',
          kpi.trend
        ]),
        metadata: {
          generatedAt: format(now, 'yyyy-MM-dd HH:mm:ss'),
          generatedBy: 'Executive Team',
          period: 'Last 30 days',
          restaurant: 'Krong Thai Restaurant'
        },
        summary: {
          'Total KPIs': rawData.length,
          'KPIs on Target': rawData.filter(kpi => kpi.target && kpi.value >= kpi.target).length,
          'Trending Up': rawData.filter(kpi => kpi.trend === 'up').length,
          'Needs Attention': rawData.filter(kpi => kpi.trend === 'down').length
        }
      };
  }
}

/**
 * Main export function that handles all formats
 */
export function exportAnalyticsReport(
  type: 'sop' | 'training' | 'operational' | 'executive',
  rawData: any[],
  charts: ChartData[] = [],
  options: ExportOptions
): void {
  const formattedData = formatAnalyticsData(type, rawData, options.locale);
  
  switch (options.format) {
    case 'csv':
      exportToCSV(formattedData, options);
      break;
    case 'excel':
      exportToExcel(formattedData, options);
      break;
    case 'pdf':
      exportToPDF(formattedData, charts, options);
      break;
    default:
      throw new Error(`Unsupported export format: ${options.format}`);
  }
}