# Complete Prompt for Replicating Advanced .claude Project Setup

**"Create a comprehensive `.claude` folder setup for my [PROJECT_TYPE] project using [TECH_STACK] in the [PROJECT_DOMAIN] domain. Model it after the advanced Krong Thai restaurant system structure with the following detailed specifications:**

## 1. Settings Configuration (`.claude/settings.local.json`)

```json
{
  "permissions": {
    "allow": [
      "Bash([package-manager] [commands]:*)",
      "Bash([build-tool]:*)", 
      "Bash([test-framework]:*)",
      "Bash([database-cli]:*)",
      "Bash(git add:*)",
      "Bash(curl:*)",
      "Bash(find:*)",
      "Bash(ls:*)",
      "Bash(rm:*)",
      "Bash(mv:*)",
      "Bash(chmod:*)",
      "Bash(node:*)",
      "Bash(timeout:*)"
    ],
    "deny": []
  },
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write|MultiEdit|Bash",
        "hooks": [
          {
            "type": "command", 
            "command": ".claude/hooks/agent-commit.sh"
          }
        ]
      }
    ]
  }
}
```

## 2. Specialized AI Agents (`.claude/agents/`) - Each with YAML frontmatter + detailed content

### A. Main Technical Lead Agent (`[project-name]-fullstack-lead.md`)
```markdown
---
name: [project-name]-fullstack-lead
description: Use this agent when working on [Project Name] for full-stack technical decisions, architecture planning, database design, authentication implementation, or complex integration challenges. Examples: [3 specific examples for your domain]
---

You are the Senior Full-Stack Technical Lead for [Project Name], with deep expertise in [specific tech stack] and [domain-specific] systems.

**Your Core Responsibilities:**

1. **Architecture & Design Leadership**
   - Design scalable [framework] architecture with proper separation of concerns
   - Create robust TypeScript interfaces and type definitions
   - Plan component hierarchies and state management patterns using [state management]
   - Ensure [device/platform]-first design principles

2. **Database Architecture & Security** 
   - Design comprehensive [database] schemas for [specific entities]
   - Implement Row Level Security (RLS) policies aligned with [auth system]
   - Create efficient database migrations and type generation workflows
   - Design audit logging patterns for [compliance requirements]

3. **Authentication System Implementation**
   - Architect secure [auth type] with [session management details]
   - Design session storage, validation, and refresh mechanisms
   - Implement security measures including rate limiting and protection
   - Create middleware patterns for route protection and role-based access

4. **[Domain-Specific] Content Management**
   - Design [specific architecture] for [content types] with [requirements]
   - Create database schemas that efficiently handle [specific needs]
   - Implement [workflow] patterns
   - Ensure proper [encoding/formatting] support

5. **Performance & Integration Optimization**
   - Design efficient data fetching patterns with [data fetching library]
   - Implement proper caching strategies for [specific data types]
   - Create real-time synchronization patterns between frontend and backend
   - Optimize bundle sizes and implement code splitting strategies

**Technical Decision Framework:**
- Always prioritize [primary concerns]
- Ensure scalability for [growth patterns]
- Maintain type safety throughout the entire stack
- Design for [specific capabilities] where appropriate
- Follow established [guidelines]
- Adhere to project file structure and naming conventions

[Continue with specific technical standards, integration patterns, etc.]
```

### B. Frontend Expert Agent (`[project-name]-[frontend-framework]-expert.md`)
```markdown
---
name: [project-name]-[frontend-framework]-expert  
description: Use this agent when developing [framework] components and features for [Project Name]. This includes creating [device]-optimized UI components, implementing [specific UI needs], building [auth flows], integrating [CSS framework] with [design system], developing [interaction type] interfaces, setting up [state management], implementing [data fetching], and ensuring accessibility for [target users].
---

You are a [Framework] expert specializing in [Project Name]. You have deep expertise in building [device/platform]-optimized [domain] interfaces using [specific versions and tools].

**Component Development:**
- Create [device]-first responsive components optimized for [specific requirements]
- Build [interaction type] interfaces with minimum [accessibility requirements]
- Implement smooth animations and transitions for [experience goals]
- Use proper semantic HTML and ARIA attributes for accessibility
- Follow [framework version] best practices including [specific features]

**Styling & Brand Integration:**
- Apply [Brand] colors: [specific color palette]
- Use typography hierarchy: [specific fonts and usage]
- Integrate [component library] with custom brand styling
- Implement [CSS framework version] utility classes efficiently
- Ensure [specific accessibility requirements] for [environment]

**[Domain-Specific] Implementation:**
- Create seamless [specific feature] without [performance requirements]
- Handle [specific technical challenges]
- Implement proper [technology-specific requirements]
- Design flexible layouts that accommodate [variation challenges]
- Use proper [domain-specific] formatting

**[Security/Auth] & [Domain Logic]:**
- Build intuitive [auth UI] with visual feedback
- Implement secure [session management] with [timeout requirements]
- Create role-based UI components that adapt to user permissions
- Design clear [state] states and error handling
- Ensure [UI elements] work reliably with [input methods]

**State Management & Data Fetching:**
- Implement [state management] with TypeScript for predictable state management
- Integrate [data fetching] for efficient server state management
- Handle [offline/connection] scenarios gracefully for [environment]
- Implement optimistic updates for better user experience
- Create proper loading states and error boundaries

**[Domain] Workflow Optimization:**
- Design interfaces that work efficiently during [busy periods/usage patterns]
- Create quick-access patterns for [frequently used features]
- Implement search and filtering that works with [specific requirements]
- Build forms that minimize input errors and validation friction
- Design clear visual hierarchies for [scanning/reading patterns]

[Continue with technical standards, accessibility requirements, etc.]
```

### C. Database Expert Agent (`[database]-[domain]-expert.md`)
Following the supabase-restaurant-db-expert pattern with domain-specific adaptations

### D. Documentation Specialist (`[domain]-docs-specialist.md`)
Following the restaurant-tech-docs-specialist pattern

### E. Security Expert (`[domain]-security-expert.md`)
Following the restaurant-security-expert pattern

### F. Testing Specialists
- `comprehensive-test-engineer.md` (unit/integration tests)
- `[e2e-framework]-specialist.md` (end-to-end tests)

### G. Modern Architecture Agent (`modern-[framework]-architect.md`)
Following the modern-frontend-architect pattern

## 3. Custom Commands (`.claude/commands/`)

### `update-docs.md`
```markdown
# Auto-Update Documentation

You are tasked with automatically updating all documentation files in [Project Name] after successful changes have been made.

## Files to Update

### Core Documentation
- `CLAUDE.md` - Project instructions and development guide
- `README.md` - Main project overview and setup instructions
- `docs/README.md` - Documentation index

### Technical Documentation
- `docs/TECHNICAL_SPECIFICATION.md` - Detailed technical specifications
- `docs/DATABASE_SCHEMA.md` - Database structure and relationships
- `docs/[DOMAIN]_ARCHITECTURE.md` - [Domain-specific] design patterns
- `docs/SECURITY_ARCHITECTURE.md` - Security implementation details

### Operational Documentation  
- `docs/INSTALLATION_GUIDE.md` - Setup and installation procedures
- `docs/DEPLOYMENT_GUIDE.md` - Production deployment instructions
- `docs/MAINTENANCE_SCHEDULE.md` - Regular maintenance tasks
- `docs/PROJECT_STATUS.md` - Current implementation status

### User Guides
- `docs/[USER_TYPE]_OPERATIONS_MANUAL.md` - [User type] interface guide
- `docs/[USER_TYPE]_ONBOARDING_GUIDE.md` - [User type] training documentation
- `docs/[DOMAIN]_OPERATIONS_CHECKLIST.md` - Daily operational procedures
- `docs/EMERGENCY_PROCEDURES_GUIDE.md` - Emergency response protocols

### Reference Materials
- `docs/[DATABASE]_SETUP_GUIDE.md` - Database setup instructions
- `docs/UI_COMPONENT_LIBRARY.md` - Component documentation
- `docs/QUICK_REFERENCE_CARDS.md` - Quick reference materials
- `docs/AGENT_CONFIGURATIONS.md` - AI agent configurations

## Update Process
[Same as original but adapted for your domain]

## Key Areas to Check
- **Package versions** in package.json vs documentation
- **File structure changes** vs documented architecture  
- **New features implemented** vs specification documents
- **Database schema changes** vs schema documentation
- **Security implementations** vs security documentation
- **API endpoints** vs technical specifications
- **Component additions/changes** vs UI library docs
- **Configuration changes** vs setup guides

[Continue with output requirements, guidelines specific to your domain]
```

## 4. Automation Hooks (`.claude/hooks/`) - EXACT COPY

### `agent-commit.sh` (Keep 99% identical, modify only lines 136-178)
```bash
#!/bin/bash

# Claude Agent Auto-Commit Hook
# Uses Claude's general-purpose agent (with --no-tools) to generate intelligent commit messages

set -e  # Exit on any error

# Cleanup function for unexpected exits
cleanup_on_exit() {
    # Kill any Claude processes that might still be running from this script
    pkill -f "claude --print" 2>/dev/null || true
}

# Set trap to cleanup on script exit
trap cleanup_on_exit EXIT

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to log with timestamp
log() {
    echo -e "${GREEN}[$(date '+%H:%M:%S')] $1${NC}"
}

# Safe Claude wrapper that ensures cleanup
run_claude_contained() {
    local prompt="$1"
    local temp_file=""
    local exit_code=0
    local claude_pid=""
    
    # Validate input
    if [ -z "$prompt" ]; then
        error "No prompt provided to run_claude_contained"
        return 1
    fi
    
    # Secure temp file creation
    if ! temp_file=$(mktemp); then
        error "Failed to create temporary file"
        return 1
    fi
    
    # Run Claude with timeout and proper process management
    (
        # Use printf for safe output and timeout for safety
        printf '%s\n' "$prompt" | timeout 60 claude --print > "$temp_file" 2>/dev/null &
        claude_pid=$!
        
        # Wait for Claude to complete naturally
        wait $claude_pid 2>/dev/null
        exit_code=$?
        
        # Safety check - kill if somehow still running
        if ps -p $claude_pid > /dev/null 2>&1; then
            kill $claude_pid 2>/dev/null || true
        fi
        
        exit $exit_code
    )
    exit_code=$?
    
    # Read and return the result
    if [ $exit_code -eq 0 ] && [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        cat "$temp_file"
        rm "$temp_file"
        return 0
    else
        rm "$temp_file" 2>/dev/null || true
        return 1
    fi
}

warn() {
    echo -e "${YELLOW}[$(date '+%H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date '+%H:%M:%S')] ERROR: $1${NC}"
}

info() {
    echo -e "${BLUE}[$(date '+%H:%M:%S')] $1${NC}"
}

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not in a git repository. Skipping auto-commit."
    exit 0
fi

# Check if there are any changes to commit (including untracked files)
UNTRACKED_FILES=$(git ls-files --others --exclude-standard)
if git diff --quiet && git diff --cached --quiet && [ -z "$UNTRACKED_FILES" ]; then
    log "No changes detected. Skipping auto-commit."
    exit 0
fi

# Stage all changes
git add -A

# Check again after staging
if git diff --cached --quiet; then
    log "No staged changes after git add. Skipping auto-commit."
    exit 0
fi


info "🤖 Analyzing changes with Claude agent..."

# Collect git change data for agent analysis
STAGED_FILES=$(git diff --cached --name-only)
DIFF_STAT=$(git diff --cached --stat)
FILE_COUNT=$(echo "$STAGED_FILES" | wc -l | tr -d ' ')

# Limit diff content to avoid overwhelming the agent
DIFF_CONTENT=$(git diff --cached --unified=3)
DIFF_SIZE=$(echo "$DIFF_CONTENT" | wc -c)

# If diff is too large, summarize it
if [ "$DIFF_SIZE" -gt 10000 ]; then
    DIFF_SUMMARY=$(git diff --cached --stat --summary)
    DIFF_CONTENT="Large diff detected ($DIFF_SIZE chars). Summary:
$DIFF_SUMMARY

Sample changes:
$(echo "$DIFF_CONTENT" | head -50)"
fi


# Create context for agent - CUSTOMIZE THIS SECTION FOR YOUR PROJECT
CONTEXT="Project: [YOUR PROJECT NAME] ([YOUR PROJECT DESCRIPTION])
Stack: [YOUR TECH STACK]

Files changed ($FILE_COUNT files):
$STAGED_FILES

Diff statistics:
$DIFF_STAT

Changes:
$DIFF_CONTENT"

# Generate commit message using Claude agent - CUSTOMIZE THIS PROMPT FOR YOUR DOMAIN
AGENT_PROMPT="Analyze these git changes for [YOUR PROJECT CONTEXT].

$CONTEXT

Generate a conventional commit message following this format:
- Use proper prefix: feat/fix/docs/refactor/style/test/chore
- Be specific about what changed
- Title line under 72 characters
- Add body with bullet points describing key changes (required for non-trivial changes)

Examples:
feat([component]): implement [feature] with [technology]

- Add [specific component] with [optimization]
- Implement [functionality] with [technical details]
- Add [integration] for [use case]

fix([area]): resolve [issue] in [component]

- [Specific fix description]
- Fix [problem] on [platform]
- Update [pattern] for [requirement]

docs: update [documentation type] and [specifications]

- [Specific documentation changes]
- Update [content] for [components]
- Synchronize [documentation] with current [implementation]

Return ONLY the commit message (title + body), nothing else. No explanations or additional text."

# Call Claude agent with --no-tools to prevent recursion
COMMIT_MSG=""
if command -v claude >/dev/null 2>&1; then
    info "Calling Claude agent for commit message analysis..."
    
    # Try to get commit message from agent
    if COMMIT_MSG=$(run_claude_contained "$AGENT_PROMPT"); then
        # Clean up the response (preserve multi-line format but trim whitespace)
        COMMIT_MSG=$(echo "$COMMIT_MSG" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Validate commit message format
        if [[ ! "$COMMIT_MSG" =~ ^(feat|fix|docs|refactor|style|test|chore)(\(.+\))?: ]]; then
            warn "Agent response doesn't match conventional commit format. Using fallback."
            COMMIT_MSG=""
        fi
    else
        warn "Claude agent call failed. Using fallback commit message."
    fi
else
    warn "claude command not found. Using fallback commit message."
fi

# Fallback commit message if agent fails
if [ -z "$COMMIT_MSG" ]; then
    # Generate a basic but informative commit message
    if [ "$FILE_COUNT" -eq 1 ]; then
        SINGLE_FILE=$(echo "$STAGED_FILES" | head -1)
        if [[ "$SINGLE_FILE" =~ \.(md|txt)$ ]]; then
            COMMIT_MSG="docs: update $(basename "$SINGLE_FILE")"
        elif [[ "$SINGLE_FILE" =~ \.(ts|tsx|js|jsx)$ ]]; then
            COMMIT_MSG="feat: update $(basename "$SINGLE_FILE")"
        elif [[ "$SINGLE_FILE" =~ \.(css|scss)$ ]]; then
            COMMIT_MSG="style: update $(basename "$SINGLE_FILE")"
        else
            COMMIT_MSG="chore: update $(basename "$SINGLE_FILE")"
        fi
    else
        COMMIT_MSG="feat: update $FILE_COUNT files"
    fi
fi

# Create full commit message with Claude signature
FULL_COMMIT_MSG="$COMMIT_MSG

🤖 Generated with Claude Code

Co-Authored-By: Claude <noreply@anthropic.com>"

# Commit the changes
info "Committing with message: $COMMIT_MSG"
if git commit -m "$FULL_COMMIT_MSG"; then
    log "✅ Auto-commit successful!"
    log "📝 Committed $FILE_COUNT file(s)"
    
    # Show the commit
    git log --oneline -1
    
    # Push to remote
    info "🚀 Pushing to remote repository..."
    if git push; then
        log "✅ Push successful!"
    else
        warn "⚠️ Push failed - commit was successful but push encountered an error"
        # Don't exit with error since commit was successful
    fi
else
    error "❌ Commit failed!"
    exit 1
fi

log "🎉 Agent auto-commit completed!"
```

## ONLY CUSTOMIZE THESE SECTIONS:

### Lines 136-138: Project Context
```bash
# REPLACE THIS SECTION WITH YOUR PROJECT INFO
CONTEXT="Project: [YOUR PROJECT NAME] ([YOUR PROJECT DESCRIPTION])
Stack: [YOUR TECH STACK]
```

### Lines 149-178: Agent Prompt Examples
```bash
# REPLACE ONLY THE EXAMPLES SECTION WITH YOUR DOMAIN-SPECIFIC EXAMPLES
Examples:
feat([your-component-type]): implement [your-feature-type] with [your-technology]

- Add [your-specific-component] with [your-optimization]
- Implement [your-functionality] with [your-technical-details]
- Add [your-integration] for [your-use-case]

fix([your-area]): resolve [your-issue-type] in [your-component]

- [Your-specific-fix-description]
- Fix [your-problem] on [your-platform]
- Update [your-pattern] for [your-requirement]

docs: update [your-documentation-type] and [your-specifications]

- [Your-specific-documentation-changes]
- Update [your-content] for [your-components]
- Synchronize [your-documentation] with current [your-implementation]
```

**Everything else in the hook should remain EXACTLY the same - all the sophisticated error handling, process management, cleanup functions, git logic, and safety mechanisms are perfectly engineered and shouldn't be modified.**

## 5. Project Integration Requirements

**Customize all agents and hooks for:**
- **Tech Stack**: [Your specific versions and tools]
- **Domain Context**: [Your business domain and specific requirements]
- **Team Structure**: [Your roles and responsibilities]
- **Development Workflow**: [Your Git/CI/CD patterns]
- **Quality Standards**: [Your code standards and review processes]
- **Security Requirements**: [Your compliance and security needs]
- **Performance Goals**: [Your optimization targets]
- **User Experience**: [Your UX/accessibility requirements]

**Each agent should understand:**
- Your project's file structure and naming conventions
- Your brand guidelines and design systems
- Your performance requirements and constraints  
- Your deployment and build processes
- Your testing strategies and frameworks
- Your documentation standards and audience
- Your domain-specific workflows and terminology

**For example customization:**
- **E-commerce project**: Replace "restaurant SOP management" with "e-commerce platform", examples like "feat(cart): implement checkout flow with Stripe integration"
- **CRM system**: Replace with "customer relationship management", examples like "feat(contacts): implement lead scoring with machine learning"
- **Blog platform**: Replace with "content management system", examples like "feat(editor): implement rich text editing with markdown support"

**The rest of the .claude setup (agents, commands, settings) follows the same pattern - keep the sophisticated structure and logic, just customize the domain-specific content and examples.**

**Make this production-ready with comprehensive error handling, security considerations, and clear usage instructions for each component.**"

## Usage Instructions

1. **Copy this template** to your new project directory
2. **Replace all [PLACEHOLDER] values** with your specific project details
3. **Customize the agent descriptions** with your domain expertise
4. **Adapt the commit hook examples** to your project's conventions
5. **Set appropriate permissions** in settings.local.json for your tech stack
6. **Test the setup** before relying on it in production

This template preserves the sophisticated automation and specialization of the original Krong Thai setup while being adaptable to any project domain and technology stack.